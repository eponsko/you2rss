from concurrent.futures import ThreadPoolExecutor
from django.conf import settings
from django.contrib.sites.shortcuts import get_current_site
from django.db.models import Count,F
from django.http import HttpResponse, FileResponse, Http404, HttpResponseRedirect
from django.shortcuts import redirect
from django.template import loader
from django.urls import reverse
from django.views.decorators.http import condition
from feedgen.feed import FeedGenerator
from xml.etree.ElementTree import Element, SubElement, Comment, tostring
import datetime, glob, logging, mimetypes, os, time, youtube_dl
from .models import Channel, Video, Podcast, Pod
from .forms import ChannelForm

try:
    FileNotFoundError
except NameError:
    # py2
    FileNotFoundError = IOError

executor = ThreadPoolExecutor(max_workers=4)
mimetypes.init()

log = logging.getLogger(__name__)

downloaded_file = None


def my_hook(d):
    if d['status'] == 'finished':
        global downloaded_file
        downloaded_file = d['filename']
        log.info('Download of "' + downloaded_file + '" complete. Time: ' + d['_elapsed_str'] + ' size: ' + d[
            '_total_bytes_str'] + ' , converting it...')

def latest_video_channel(request, channel_id):    
    channel = Channel.objects.get(channel_id=channel_id)
    if not channel:
        return ""
    return channel.latest_video
    
def latest_video_channel_etag(request, channel_id):
    channel = Channel.objects.get(channel_id=channel_id)
    if not channel:
       return ""

    video = channel.video_set.order_by('-pub_date')[0]
    if video:
        return video.video_id
    return ""
    
def generateopml(request):
    generated_on = str(datetime.datetime.now())
    root = Element('opml')
    root.set('version', '2.0')
    root.set('xmlns:pk','http://www.podkicker.com/backup.dtd') 
    root.append(Comment('Generated by you2rss'))
    head = SubElement(root, 'head')
    title = SubElement(head, 'title')
    title.text = 'You2Rss podcasts'
    dc = SubElement(head, 'dateCreated')
    dc.text = generated_on
    dm = SubElement(head, 'dateModified')
    dm.text = generated_on
    body = SubElement(root, 'body')
    latest_channel_list = Channel.objects.all()
    for channel in latest_channel_list:
        channelURL = ''.join(['http://', get_current_site(request).domain,
                          reverse('you2rss:rssfile', args=(channel.channel_id,))])
        podcast = SubElement(body, 'outline', {'text':channel.title_text,
                                               'xmlUrl':channelURL,
                                               'pk:autodownload':"0", 'pk:cachelimit':"0",'pk:notify':"0",})
        
    return HttpResponse(tostring(root), content_type="text/x-opml")
    
def index(request):
    return redirect('you2rss:channels')

def listchannels(request):
    if request.method == 'POST':
        log.info("POST: "+ str(request.POST))
        form = ChannelForm(request.POST)
        log.info("Got post to /channels, form: " + str(form))
        if form.is_valid():
            channelid = form.cleaned_data['channel_id']
            from .cron import UpdateChannels
            a = UpdateChannels()
            log.info("Attempting to add channel '" + channelid + "'")
            a.add_channel(channelid)
        else:
            log.info("Invalid form: "+ str(form.errors))
        return HttpResponseRedirect('/you2rss/channel')
    else:
        form = ChannelForm()
        latest_channel_list = Channel.objects.order_by('-latest_video').annotate(num_vids=Count('video'))
        template = loader.get_template('you2rss/index.html')
        context = {
            'latest_channel_list': latest_channel_list,
            'form' : form,
        }
        return HttpResponse(template.render(context, request))

def listvideos(request):
    return HttpResponse('Video list')


def latest_entry(request):
    newest = None
    podcast = Podcast.objects.filter(dynamic = True).latest('latest_pod').latest_pod
    channel = Channel.objects.latest('latest_video').latest_video
    if podcast and channel:
        if podcast > channel:
            return podcast
        else:
            return channel
    elif podcast:
        return podcast
    elif channel:
        return channel
    else:
        return None
    
@condition(last_modified_func=latest_entry)
def latest(request):
    from itertools import chain
    pod_list = Pod.objects.filter(podcast__dynamic = True).order_by('-pub_date').select_related('podcast')[:100]
    vid_list = Video.objects.order_by('-pub_date').select_related('channel')[:100]
#    result_list = list(chain(pod_list, vid_list))
    result_list = sorted(chain(pod_list, vid_list),reverse=True,  key=lambda instance: instance.pub_date)
    template = loader.get_template('you2rss/latest.html')
    context = {
        'pod_list': result_list,
    }
    return HttpResponse(template.render(context, request))

def latest_podcast(request):
    return Podcast.objects.latest('latest_pod').latest_pod

@condition(last_modified_func=latest_podcast)
def listpodcasts(request):
    latest_podcast_list = Podcast.objects.order_by('-latest_pod').annotate(num_pobs=Count('pod'))
    template = loader.get_template('you2rss/podcasts.html')
    context = {
        'latest_podcast_list': latest_podcast_list,
    }
    return HttpResponse(template.render(context, request))

def listpodspodcast(request,podcast_id):
    podcast  = Podcast.objects.get(id=podcast_id)
    if podcast.dynamic:
        pod_list = podcast.pod_set.order_by('-pub_date')
    else:
        pod_list = podcast.pod_set.order_by('-audio_link')
    template = loader.get_template('you2rss/pods.html')
    context = {
        'pod_list': pod_list,
        'podcast_title': podcast.title_text,
        'podcast_thumb': podcast.thumbnail,
        'description': podcast.description_text
    }
    return HttpResponse(template.render(context, request))

@condition(etag_func=latest_video_channel_etag, last_modified_func=latest_video_channel)
def listvideoschannel(request, channel_id):
    channel = Channel.objects.get(channel_id=channel_id)
    video_list = channel.video_set.order_by('-pub_date')
    template = loader.get_template('you2rss/videos.html')
    context = {
        'video_list': video_list,
        'channel_title': channel.title_text,
        'channel_thumb': channel.thumbnail,
        'description': channel.description_text
    }
    return HttpResponse(template.render(context, request))


def rsschannels(request):
    return HttpResponse('combined rss feed here')

def test(request, vid):
    data = '''
    '''
    return HttpResponse(data)


def latest_staticpod(request, podcast_id):
    return Podcast.objects.filter(id=podcast_id).latest("latest_pod").latest_pod

@condition(last_modified_func=latest_staticpod)
def staticrss(request, podcast_id):
    podcast = Podcast.objects.get(id=podcast_id)
    if not podcast:
        return Http404

    pods = podcast.pod_set.order_by('-audio_link')
    fg = FeedGenerator()
    fg.load_extension('podcast')

    channelURL = ''.join(['http://', get_current_site(request).domain,
                          reverse('you2rss:staticrss', args=(podcast_id,))])
    fg.id(channelURL)
    fg.title(podcast.title_text)
    fg.author({'name': 'pon sko', 'email': 'john@example.de'})
    fg.link(href=channelURL, rel='alternate')
    description = podcast.description_text
    if len(description) < 2:
        description = "no desc"
    fg.subtitle(description)
    fg.description(description)
    fg.language('en')
    fg.logo(logo=podcast.thumbnail)
    fg.image(url=podcast.thumbnail, title=podcast.title_text)
    fg.podcast.itunes_image(podcast.thumbnail)
    for pod in pods:
        fe = fg.add_entry()
        fe.author(name=podcast.title_text)
        desc = pod.description_text
        if len(desc) < 2:
           desc = "no desc"
        fe.content(desc)
        fileURL = pod.audio_link
        #''.join(['http://', get_current_site(request).domain,
        #                   reverse('you2rss:rssfile', args=(video.video_id,))])

        fe.enclosure(fileURL, pod.audio_size, pod.audio_type)
        fe.id(fileURL)
        fe.link(href=fileURL, rel='alternate')
        fe.podcast.itunes_image(podcast.thumbnail)
        fe.pubdate(pod.pub_date)
        fe.published(pod.pub_date)
        fe.title(pod.title_text)

    rssdata = fg.rss_str(pretty=True)
    response = HttpResponse(rssdata, content_type='application/rss+xml; charset=UTF-8')
    response['Content-Length'] = len(rssdata)
    return response




@condition(last_modified_func=latest_video_channel)
def rssvideoschannel(request, channel_id):
    channel = Channel.objects.get(channel_id=channel_id)
    if not channel:
       return Http404

    videos = channel.video_set.order_by('-pub_date')
    fg = FeedGenerator()
    fg.load_extension('podcast')

    channelURL = ''.join(['http://', get_current_site(request).domain,
                          reverse('you2rss:videoperchannel', args=(channel_id,))])
    fg.id(channelURL)
    fg.title(channel.title_text)
    fg.author({'name': 'pon sko', 'email': 'john@example.de'})
    fg.link(href=channelURL, rel='alternate')
    description = channel.description_text
    if len(description) < 2:
        description = "no desc"
    fg.subtitle(description)
    fg.description(description)
    fg.language('en')
    fg.logo(logo=channel.thumbnail)
    fg.image(url=channel.thumbnail, title=channel.title_text)
    fg.podcast.itunes_image(channel.thumbnail)

    for video in videos:
        fe = fg.add_entry()
        fe.author(name=channel.title_text)
        videodesc = video.description_text
        if len(videodesc) < 2:
            videodesc = "no desc"
        fe.content(videodesc)
        fileURL = ''.join(['http://', get_current_site(request).domain,
                           reverse('you2rss:rssfile', args=(video.video_id,))])

        fe.enclosure(fileURL, '1337', 'audio/mpeg')
        fe.id(fileURL)
        fe.link(href=fileURL, rel='alternate')
        fe.podcast.itunes_image(video.thumbnail)
        fe.pubdate(video.pub_date)
        fe.published(video.pub_date)
        fe.title(video.title_text)

    rssdata = fg.rss_str(pretty=True)
    response = HttpResponse(rssdata, content_type='application/rss+xml; charset=UTF-8')
    response['Content-Length'] = len(rssdata)
    return response


def download(request, vid):
    executor.submit(startDownload, vid)
    template = loader.get_template('you2rss/started.html')
    context = {
        'vid': vid,
    }
    return HttpResponse(template.render(context, request))


def file(request, vid):
    filepath = settings.FILE_LOCATION + vid + '_out.*'
    txt = glob.glob(filepath)
    for textfile in txt:
        if os.path.exists(textfile):
            response = FileResponse(open(textfile, 'rb'))
            response['Content-Type'] = mimetypes.guess_type(textfile)[0]
            log.info(response['Content-Type'])
            response['Content-Length'] = os.path.getsize(textfile)
            return response
    return Http404


def rssfile(request, vid):
    filepath = settings.FILE_LOCATION + vid + '_out.*'
    txt = glob.glob(filepath)
    for textfile in txt:
        if os.path.exists(textfile):
            return HttpResponseRedirect('http://' + get_current_site(request).domain + '/' + textfile)
            response = FileResponse(open(textfile, 'rb'))
            response['Content-Type'] = mimetypes.guess_type(textfile)[0]
            response['Content-Length'] = os.path.getsize(textfile)
            return response
    startDownload(vid)
    txt = glob.glob(filepath)
    for textfile in txt:
        if os.path.exists(textfile):
            return HttpResponseRedirect('http://' + get_current_site(request).domain + '/' + textfile)
            response = FileResponse(open(textfile, 'rb'))
            response['Content-Type'] = mimetypes.guess_type(textfile)[0]
            response['Content-Length'] = os.path.getsize(textfile)
            return response
    return Http404


def startDownload(vid):
    v = Video.objects.get(video_id=vid)
    ydl_opts = {
        'format': 'worstaudio/worst',
        'keepvideo': 'false',
        'outtmpl': settings.FILE_LOCATION + vid + '_out.%(ext)s',
        'postprocessors': [{
            'key': 'FFmpegExtractAudio',
            'preferredcodec': 'best'
        }],
        'logger': log,
        'progress_hooks': [my_hook],
    }

    try:
        with youtube_dl.YoutubeDL(ydl_opts) as ydl:
            url = 'http://www.youtube.com/watch/?v=' + vid
            log.info('Downloading of "' + vid + '" started')
            a = ydl.download([url])
            filepath = settings.FILE_LOCATION + vid + '_out.*'
            txt = glob.glob(filepath)

            log.info('Files found : ' + str(txt) + ' len: ' + str(len(txt)))

            if len(txt) == 1:
                log.info('Download and conversion successful')
                v.downloaded = True
                v.save()
            elif len(txt) > 1:
                # cleanup wasn't performed
                try:
                    log.info('Removing file "' + downloaded_file + '"')
                    os.remove(downloaded_file)
                except OSError:
                    log.error('Tried to delete file "' + downloaded_file + '" but failed')
                v.downloaded = True
                v.save()
            else:
                log.error('Download of "' + vid + '" failed, output file does not exist')

    except youtube_dl.DownloadError as e:
        log.error('exception downloadning: ' + str(e))
    except Exception as e:
        log.error('caught exception')
        log.error("I/O error({0}): {1}".format(e.errno, e.strerror))

